import java.util.Arrays;

/**
 * In a network of nodes, each node i is directly connected to another node j if and only if 
 * graph[i][j] = 1.
 * Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected 
 * and at least one of those two nodes is infected by malware, both nodes will be infected by 
 * malware.  This spread of malware will continue until no more nodes can be infected in this manner.
 * Suppose M(initial) is the final number of nodes infected with malware in the entire network, 
 * after the spread of malware stops.
 * We will remove one node from the initial list.  Return the node that if removed, would minimize 
 * M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with 
 * the smallest index.
 * Note that if a node was removed from the initial list of infected nodes, it may still be infected 
 * later as a result of the malware spread.
 * Example 1:
 * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * Output: 0
 * Example 2:
 * Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * Output: 0
 * Example 3:
 * Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * Output: 1
 * Note:
 * 1. 1 < graph.length = graph[0].length <= 300
 * 2. 0 <= graph[i][j] == graph[j][i] <= 1
 * 3. graph[i][i] = 1
 * 4. 1 <= initial.length < graph.length
 * 5. 0 <= initial[i] < graph.length
 * @author wendi
 *
 */
public class MinimizeMalwareSpread {
	
	
	/**
	 * Stain color + dfs
	 * @param int[][] graph, int[] initial
	 * @return int
	 * Time: O(n^2)
	 * Space: O(n)
	 */
	public int minimizeMalwareSpread(int[][] graph, int[] initial) {
        if (graph == null || graph.length == 0 || graph[0].length == 0) return -1;
        if (initial == null || initial.length == 0) return -1;
        int n = graph.length;
        
        int[] groups = new int[n];        // node in which group
        cluster(graph, groups);
        
        int[] groupSizes = new int[n + 1];    // how many nodes in each group
        for (int group: groups) {
            groupSizes[group]++;
        }
        
        int[] groupInitSizes = new int[n + 1]; // how many initial nodes in group
        for (int node: initial) {
            groupInitSizes[groups[node]]++;
        }
        
        Arrays.sort(initial);
        int resNode = initial[0];
        int maxRemoveNodes = 0;
        for (int node: initial) {
            int group = groups[node];
            if (groupInitSizes[group] > 1 || groupSizes[group] <= maxRemoveNodes) continue;
            resNode = node;
            maxRemoveNodes = groupSizes[group];
        }
        
        return resNode;
            
    }
    
    private void cluster(int[][] graph, int[] groups) {
        int num = 0;
        for (int i = 0; i < graph.length; i++) {
            if (groups[i] != 0) continue;
            groups[i] = ++num;
            dfs(graph, i, groups, num);
        }
    }
    
    private void dfs(int[][] graph, int i, int[] groups, int num) {
        for (int j = 0; j < graph.length; j++) {
            if (graph[i][j] == 0 || groups[j] != 0) continue;
            groups[j] = num;
            dfs(graph, j, groups, num);
        }
    }

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		MinimizeMalwareSpread result = new MinimizeMalwareSpread();
		System.out.println(result.minimizeMalwareSpread(
				new int[][] {{1,0,0,0},{0,1,0,0},{0,0,1,1},{0,0,1,1}}, new int[] {3,1}));
	}

}
